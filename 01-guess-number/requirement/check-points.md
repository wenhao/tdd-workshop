### 创建项目
1. 使用github托管项目
2. 使用maven或者gradle构建项目
3. 添加junit、mockito、guava依赖
4. 能够执行测试并build成功通过

### 任务分解
TDD 的一个重要步骤是在分析需求之后, 对其进行任务分解。每个任务相当于一个功能点,它们都是可以验证的。
在进行TDD时, 可以根据具体情况, 对任务再进行分解, 或者增加一些我们之前未曾发现的任务。

### 为什么要Tasking？

Tasking就是将一个原本的较大的需求，分解成一个个很小的需求。实现一个大的需求，往往需要比较长的时间。但是如果实现一个很小的需求，小的不能再小的需求时，往往是非常容易的。通过这样的方式，可以缩短我们红绿重构的周期，得到快速的反馈。

这里需要注意的是Tasking不是实现过程的拆分，而是需求的拆分。

### 为什么要选择最简单的Task先做？

一般来说，简单的Task对应简单的实现，复杂的Task对应复杂的实现。并且复杂的Task往往涵盖了简单的Task。所以，选择简单的Task，后实现复杂的Task，已有的简单Task的实现将有助于让复杂的Task实现变得更容易。反之，如果首先实现了复杂的Task，那么你的代码可能将会陷入某种不必要的抽象，再实现其他的Task时，可能就需要重写。

于是，问题变成了，什么是“简单”的Task呢？什么又是“最简单“的Task呢？

一言蔽之，就是你能用最短时间实现的Task。

### 任务分解
1. 随机生成4位不重复的数字
2. 判断每次猜测的结果
3. 判断输入是否合法
4. 记录并显示历史猜测记录
5. 判断游戏结果。判断猜测次数，如果满6次但是未猜对判断负；如果在6次内猜测的4个数字值与位置都正确，则判胜。

### 讨论：选择开始的任务
在分解好任务开始测试驱动开发时， 我们应该优先选择哪一个任务 ？选择的标准包括:

1. 任务的依赖性
2. 任务的重要性

   从依赖的角度看,并不一定需要优先选择前序任务,因为我们可以使用 Mock 的方式驱动出当前任务需要依赖的接口,而不用考虑实现。
例如,“随机生成答案”任务与“判断每次猜测的结果”任务之间存在前后序的依赖关系,但实现的顺 序却并不需要按照此顺序。

   对于任务的重要性,主要是判断任务是否整个系统(模块)的核心功能。一个判断标准是确定任务是功能的主要流程还是异常流程。
例如任务“检查输入是否合法”即为异常流程,可以考虑后做。

### 第一个任务应该是：判断每次的猜测结果

任务“判断每次的猜测结果”可以作为起始的核心任务。
在进行测试驱动时,选择好任务后,就需要对测试用例进行分析。可以假设该任务就是你要实现的一个完整功能,然后从外部调用的角度去思考用例。这体现为两个方面:

1. 选择测试样本;
2. 驱动承担该职责的对象,根据意图设计接口; 

选择测试样本的方法请参考实例化需求。例如,这里可以选择全中或全错等样本。通常情况下,编写的第一个测试应该选择最简单的样本。

知识:Specification By Example
￼￼由 Gojko Adzic 的著作 Specification By Example(实例化需求),介绍了如何通过实例去分析和沟通需求。
它是一组过程模式,可以协助软件产品的变更, 确保有效地交付正确的产品。实例化需求的过程分为:

* 从目标中获取范围
* 用实例进行描述
* 精炼需求说明
* 自动化验证,无须改变需求说明 
* 频繁验证
* 演进出一个文档系统 
更多内容,请参考该书

```
注意:单元测试不能针对方法编写测试,而应根据业务编写测试用例。 一个测试方法只能做一件事情,代表一个测试样本和一个业务规则。
```

### 思考:测试驱动开发的驱动力
设计接口是体现测试驱动开发“驱动力”的重要一点。之所以先编写测试,就是希望开发人员站在调用者的角度去思考,即所谓“意图导向编程”。
从调用者的角度思考,可以驱动我们思考并达到如下目的:

1. 如何命名被测试类以及方法,才能更好地表达设计者的意图,使得测试具有更好的可读性;
2. 被测对象的创建必须简单,这样才符合测试哲学,从而使得设计具有良好的可测试性;
3. 测试使我们只关注接口,而非实现;

### 知识:Given-When-Then模式
在编写测试方法时,应遵循Given-When-Then模式,这种方式描述了测试的准备,期待的行为,以及相关的验收条件。Given-When-Then模式体现 了TDD对设计的驱动力: 

1. 编写Given时,“驱动”我们思考被测对象的创建,以及它与其他对象的协作; 
1. 编写When时,“驱动”我们思考被测接口的方法命名,以及它需要接收的传入参数;考虑行为方式,究竟是命令式还是查询式方法(CQS原则); 
3. 编写Then时,“驱动”我们分析被测接口的返回值;

### 知识:CQS原则
CQS原则,即命令-查询分离原则(Command-Query Separation),是指一 个函数要么是一个命令来执行动作,要么是一个查询来给调用者返回数 据。但是不能两者都是。

对于任务“判断每次的猜测结果”,我们首先要考虑由谁来执行此任务。从 面向对象设计的角度来讲,这里的任务即“职责”,我们要找到职责的承担者。
从拟人化的角度去思考所谓“对象”,就是要找到能够彻底理解(Understand) 该职责的对象。遵循信息专家模式,大多数情况下,承担职责的对象常常是 拥有与该职责相关信息的信息持有者,即所谓“信息专家”。

### 知识:信息专家模式
信息专家模式(Information Expert)是 GRASP 模式中解决类的职责分配 问题的最基本的模式。
问题: 当我们为系统发现完对象和职责之后,职责的分配原则(职责将分配给哪 个对象执行)是什么?
解决方案: 职责的执行需要某些信息(information),把职责分配给该信息的拥有 者。换句话说,某项职责的执行需要某些资源,只有拥有这些资源的对象 才有资格执行职责。
优点:
- 信息的拥有者类同时就是信息的操作者类,可以减少不必要的类之间的 关联。
- 各类的职责单一明确,容易理解。

### 思考:寻找承担职责“判断每次的猜测结果”的对象 
可能的答案:Game,Player,Round

提示:应让学员充分思考承担职责的角色,不能在未经分析之前就开始 编写测试,从而忽略测试带来的驱动力,甚至忘记一些基本的命名原则 和面向对象设计思想。
例如,学员可能会将被测类命名为Guess、Check, 而被测方法也被命名为guess()、check()。

### 知识:命名规则
类命名规则:测试类与被测类的命名应保持一致,通常情况下,测试类的
名称为:被测类名称+Test后缀。例如这里的Game类为被测类,则测试类 命名为GameTest。 
方法命名规则:测试方法应表述业务含义,这样就能使得测试类可以成为 文档。测试方法可以足够长,以便于清晰地表述业务。
为了更好地辨别方 法名表达的含义,ThoughtWorks提倡用Ruby风格的命名方法,即下划线 分隔方法的每个单词,而非Java传统的驼峰风格。
建议测试方法名以 should开头,此时,默认的主语为被测类。例如:
@Test
public void should_return_0A0B_when_no_number_guessed_correctly(){
//... }
这里的方法可以阅读为:Game should return 0A0B when no number guessed correctly。显然,这是一条描述了业务规则的自然语言。

现在编写测试。由于事先已经明确被测类为Game,编写测试的Given部分, 让我们思考如何创建Game对象?是否可以简单地创建?
Game game = new Game();
分析任务,需要判断猜测结果,则必然要求获知游戏的答案。这个答案与Game 的关系是什么呢?这里产生的驱动力是如何创建Game对象?为了创建该对象, 需要提供哪些准备?这使得我们驱动出Answer类的定义。

讨论:由4个数字组成的答案是否需要封装? 学员容易写出的代码,以如下方式表现答案(Answer):

* 整数数组
* 整数类型的可变参数 
* 字符串

第一种方式除了缺乏对整数值的限制外,一个问题还在于暴露了实现细节。
第 二种方式甚至无法对答案的个数进行限制。
第三种方式则与输入有关,使得 Game类还要承担解析输入字符串的职责,违背了单一职责原则(说明:在后面, 我们为Answer类提供了工厂方法,可以将传入的字符串解析为Answer对象,也 即是由Answer承担解析输入字符串的职责,这同时也遵循“信息专家模式”。)

### 思考:Answer的定义 
我们可以从如何构造一个Answer对象着手,看看该如何定义Answer类。

### 知识:单一职责原则
由 Robert Martin提出,该原则指出:就一个类而言,应该只专注于做一件 事和仅有一个引起变化的原因。

编写 When 可以帮助开发者思考类的行为。一定要从业务而非实现的角度去思 考接口。例如:
实现角度的设计:check()
业务角度的设计:guess()
注意两个方法命名表达意图的不同。
编写 Then 实际上是考虑如何验证。没有任何验证的测试不能称其为测试。由于该任务为判断输入答案是否正确,并获得猜测结果,因而必然需要返回值。 
从需求来看,只需要返回一个形如 xAxB 的字符串即可。

### 思考:是否需要将猜测结果封装为类?
至少就目前而言,并没有必要。因为从需求来看,仅仅需要返回一个形如 xAxB 的字符串而言。这是需要遵循简单设计的要求,不必过度设计。
如前所述,任务“判断每次的猜测结果”存在多个测试样本,例如一个都不对, 或者全部正确,又或者值正确而位置不正确等,因而需要编写多个测试。在编
写第一个测试时,可以简单实现使得测试快速通过,然后随着多个测试的编写, 再驱动出检查输入数值的算法。

### 根据以上的分析,我们编写的第一个测试如下所示,它遵循了 Given-When- Then 模式:

```java
@Test
public void should_return_0A0B_when_no_number_is_correct() {
    //given
    Answer actualAnswer = Answer.createAnswer("1 2 3 4"); 
    Game game = new Game(actualAnswer);
    Answer inputAnswer = Answer.createAnswer("5 6 7 8");
    //when
    String result = game.guess(inputAnswer);
    //then
    assertThat(result , is("0A0B"));
}
```

这个测试已经驱动出了 Answer 的创建,Game 类的定义,guess()接口的定义。 在保证编译通过后,应该首先运行该测试。
此时测试必然是失败的。为了使该测试快速通过,我们可以简单实现 guess()方法,例如直接返回“0A0B”字符 串。接着,就可以编写第二个测试。

### 思考:为何要先运行一个失败的测试? 
首先,它能够保证测试框架是没有问题的;其次,它可以避免偶然的成功,因 为测试通过不等于实现一定是正确的。
在编写第二个测试时,由于测试样本与之前的测试完全不一样,之前的简单实
现就不能满足新增的测试了。事实上,测试就是要去验证实现逻辑,这其中最
重要的测试目标就是分支。不同的分支可能会返回不同的结果,如果我们根据
分支来设计测试,就能有效保障实现的正确性。这称为“三角测试法”。

常见问题:

* 没有将测试代码看做是代码的一部分。当编写多个测试方法时,没有及
时重构;例如,应及时将 game 对象与 actualAnswer 对象提取为字段,
以避免不必要的声明。
* 直接暴露表达式,而未对表达式进行方法提取,以表达业务意义;
* guess()方法过长;应该通过提取方法来改进代码的可读性;
* Game 类与 Answer 类的职责分配不合理,将 Answer 类设计为仅具有
get()和 set()的数据对象,而将判断数值是否正确、位置是否正确的逻辑 分配给了 Game。没有考虑 get()和 set()是否真正有必要;如果我们对 guess()方法进行了方法提取,可以识别出代码的坏味道“Feature Envy”,即 Game 的方法用到的都是 Answer 的属性。
这时,应该采用 移动方法的重构手法对其进行重构。

## 开始第二个任务

我们选择的第二个任务为“随机生成答案”,这是一个独立的职责。编写测试 类时,很容易驱动出AnswerGenerator类。关键在于,我们该如何编写单元测 试来验证生成的结果。我们对结果的要求是:

* 数字必须是0...9之间;
* 产生的四个数字不能相同;

讨论: 究竟由谁来承担“随机生成答案”的职责? 学员容易将此职责直接分配给Answer。

然而,随机生成答案与创建一个答案适 用于不同的场景,这对于Answer的调用者而言,并不友好。
尤其对于只需要答 案的场景,还需要无端地引入对随机数的依赖,显然是不合理的。
编写测试方法的过程与前相似,仍然按照Given-When-Then模式来编写(若测 试方法比较简单,可以不遵循这一模式,但思考的过程却应该按照该模式)。 
在编写then部分的测试时,可能出现疑问。

问题: 如何验证生成的答案是否正确? 我们已经将答案建模为Answer,因此AnswerGenerator的generate()方法要返回 的对象类型为Answer。
那么,我们怎么知道返回的Answer对象是合法的呢?一 种做法是获取Answer的属性,然后再进行验证。那么,为了测试的验证而暴 露这些属性,是否适合?

要完成对答案正确性的验证,直接暴露答案的属性是不妥当的,至少目前没有 获取答案属性的需求。
我们的做法是定义一个验证方法。这是否仍然属于为测 试而定义行为的做法呢?这个问题有点像鸡与鸡蛋的哲学问题。
我们应该还原 到设计,看看这种手法是否改善了设计,如此即可。毕竟,这种对答案正确 性的校验,也可以说是业务逻辑的一种。


说明: 在开始编写“检查输入是否合法”任务时,你会发现,这里所谓 多余的验证,就会派上用场。

这个验证方法可以是单纯的返回true或者false,但从需求来看,这个返回结果 并没有很好地展现验证要求:究竟是因为数字超出了范围,还是出现了相同的 数字?
我个人更倾向于用自定义异常来表示生成的答案违背了这两条规则。因 此,我们可以为Answer定义一个validate()方法,以验证生成的Answer是否满 足规则要求;
如果不符合,就抛出对应的异常。


问题: 如何确定测试通过就意味着实现正确?

第二个任务看似简单,实则不然。原因在于这里产生了一个随机数。随机数带 来了不确定性,它可能偶然地让测试通过了。也许,运行测试100次,前面的 99次都通过了,最后一次失败,仍然视为失败。
生成随机数自然是调用Java的JDK。在单元测试环节中,倘若我们要测试的 单元需要调用别的API,则在这个测试中,我们可以假定这个API是正确 的。我们对Java JDK的正确性自然信心十足。那么,为何我们还要考虑测试的 随机失败?这是因为在这个任务的测试中,我们测试的并非随机数的生成逻辑, 而在于随机数的种子是否恰当,实现逻辑中是否判断了可能出现的错误数字?
由于生成随机数的逻辑并非确定无疑的,测试时我们就不能依赖于它。这正是 Mock可以派上用场的时候。为此,我们需要将生成随机数的功能􏰁取为类 RandomIntGenerator,再注入到AnswerGenerator中。
``` java
public class AnswerGenerator {
    private RandomIntGenerator randomIntGenerator;
    public AnswerGenerator(RandomIntGenerator randomIntGenerator) 
    {
        this.randomIntGenerator = randomIntGenerator; 
    }
}
```

该类的实现调用了Java提供的Random类,但在测试时,我们却可以通过Mock 它的行为,使得返回的结果变为确定的数字:
``` java
@Test(expected = AnswerOutOfRangeException.class)
public void should_throw_AnswerOutOfRangeException_which_is_not_between_0_and_9() 
{
    RandomIntGenerator randomIntGenerator = mock(RandomIntGenerator.class);
    when(randomIntGenerator.nextInt()).thenReturn(1, 2, 3, 10);
    AnswerGenerator answerGenerator = new AnswerGenerator(randomIntGenerator);
    answerGenerator.generate(); 
}
```
重构: 组合Game与AnswerGenerator 在实现第一个任务时,我们定义的Game接受了Answer对象作为游戏的答案。 

现在,我们定义了AnswerGenerator用以生成符合条件的随机答案。我们当然 可以在调用该对象的generate()方法生成答案后,再将该答案作为构造函数参数 传递给Game对象。

但更好的做法是直接将AnswerGenerator作为构造函数参数 传递给Game,在其内部调用它的generate()方法。

开始第三个任务 之所以将“验证输入是否合法”放在第三个任务,是因为它不属于happy path
的范畴。它属于辅助业务,重要性相对次之。

提示: 对于第三个任务,可以采用Specification By Example的方式来考虑 测试用例。

问题: 参数 vs. 字段 学员在定义执行该任务的类时,一种可能性是将输入的答案作为类的构造函数 参数。例如:
new InputValidator("1 2 3 5").validate();

存在两个错误:

* 错误地判断了输入值的生命周期。什么内容应该放在构造函数中作为参
数?换言之,构造函数参数与对象之间的关系是什么?之所以要作为 构造函数参数,就是意味着在某种场景下这些参数值应该在创建该对象 时就存在。这些参数值与对象“生死与共”,它们的生命周期是保持一 致的。如果不是,就不应该作为构造函数的参数。你觉得输入应该作为 构造函数吗?如果我要验证另一条输入应该怎么办?再创建一个 InputValidator对象吗?
* 违反了阅读直觉。validate()方法验证谁?验证空吗?显然这样的接口违 反了主-谓-宾的语法。

问题: 封装的Answer与输入 既然已经封装了Answer对象,为何validate()方法还是要接收字符串类型的输入? 阅读需求,已可寻求到答案。

问题: 引入InputValidator类型是否有必要? 多数人会认为这里的验证逻辑与Answer相关,根据前面􏰀到的“信息专家模 式”,似乎应该将验证逻辑放到Answer中。然而,这里的需求明确地表示了, 如果输入不符合要求,就不允许创建该Answer,而是抛出异常。所以,这里的 部分验证逻辑是在创建Answer之前就应该存在,当然就不应该由Answer承担了。
针对第三个任务,验证结果的逻辑不应该由boolean型或错误码来表现。对于表 达一种错误规则来说,如果你将其看做是一种业务规则,最好的表达方式是采 用自定义异常,除非这门语言允许返回两个值(例如Go语言支持返回多个字, 但并不支持异常)。对此,在第二个任务中已有􏰁述,这里不再赘述。

重构: Answer的验证逻辑
